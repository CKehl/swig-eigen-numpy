# inverter_wrapper.Inverter is the class generated by SWIG to wrap our c++ Inverter class
from .inverter_wrapper import Inverter

# Since templatedInverse is a templated function in c++, we can't just import
# it directly into python (its code isn't fully defined until we
# decide what template arguments it takes). However, in inverter_wrapper.i
# we called:
#     %template(templatedInverse_d) templatedInverse<double>;
# which creates an explicit instantiation of templatedInverse for double-
# precision values. So we can just import that instantiation into python
# and use it instead.
from .inverter_wrapper import templatedInverse_d as templatedInverse

import numpy as np

# Here we're going to define an additional method and attach it to the Inverter class. Any python program can call this method just like any other method of Inverter, without caring whether it was defined in c++ or in python.
def Inverter_getInversePlus1(self, M):
    """
    Invert the matrix and add one to every element
    """
    inv = self.getInverse(M)
    return inv + np.ones(M.shape)
# Attach the function Inverter_getInversePlus1 to the Inverter class under the name getInversePlus1.
setattr(Inverter, "getInversePlus1", Inverter_getInversePlus1)
